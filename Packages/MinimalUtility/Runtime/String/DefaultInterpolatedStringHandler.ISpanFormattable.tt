<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ output extension=".cs" #>
<#
    var spanFormattableType = new string[]
    {
        "byte",
        "sbyte",
        "short",
        "ushort",
        "int",
        "uint",
        "long",
        "ulong",
        "float",
        "double",
        "decimal",
        "DateTime",
        "DateTimeOffset",
        "TimeSpan"
    };
#>
<#= "#if !NET6_0_OR_GREATER" #>
<#= "#nullable enable" #>

namespace System.Runtime.CompilerServices
{
    public ref partial struct DefaultInterpolatedStringHandler
    {
<# foreach (var typeStr in spanFormattableType) { #>
        public void AppendFormatted(<#= typeStr #> value)
        {
            // If there's a custom formatter, always use it.
            if (_hasCustomFormatter)
            {
                AppendCustomFormatter(value, format: null);
                return;
            }

            int charsWritten;
            while (!value.TryFormat(_chars.Slice(_pos), out charsWritten, null, _provider)) // constrained call avoiding boxing for value types
            {
                Grow();
            }

            _pos += charsWritten;
        }

        public void AppendFormatted(<#= typeStr #> value, int alignment)
        {
            int startingPos = _pos;
            AppendFormatted(value);
            if (alignment != 0)
            {
                AppendOrInsertAlignmentIfNeeded(startingPos, alignment);
            }
        }

        public void AppendFormatted(<#= typeStr #> value, string? format)
        {
            // If there's a custom formatter, always use it.
            if (_hasCustomFormatter)
            {
                AppendCustomFormatter(value, format);
                return;
            }

            int charsWritten;
            while (!value.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider)) // constrained call avoiding boxing for value types
            {
                Grow();
            }

            _pos += charsWritten;
        }

        public void AppendFormatted(<#= typeStr #> value, int alignment, string? format)
        {
            int startingPos = _pos;
            AppendFormatted(value, format);
            if (alignment != 0)
            {
                AppendOrInsertAlignmentIfNeeded(startingPos, alignment);
            }
        }

<# } #>
    }
}

<#= "#endif" #>

